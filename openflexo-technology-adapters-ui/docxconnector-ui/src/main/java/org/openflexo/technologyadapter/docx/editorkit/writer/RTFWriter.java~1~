package rtf.writer;

import java.awt.*;
import java.awt.image.*;
import java.util.*;
import java.io.*;
import com.sun.media.jai.codecimpl.*;
import com.sun.media.jai.codec.*;

import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.text.*;

import rtf.*;

/**
 * Implements writer of RTF document.
 *
 * @author	Stanislav Lapitsky
 */
public class RTFWriter {

    /**ico
     * document instance to the writing.
     */
    protected Document document;

    /**
     * list of the document's fonts.
     */
    protected Vector fontList;
    /**
     * list of the document's colors.
     */
    protected Vector colorList;

    /**
     * Constructs new writer instance.
     *
     * @param	doc document for writing.
     */
    public RTFWriter(Document doc) {
        document=doc;
    }

    /**
     * Performs writing to a file.
     *
     * @param	fileName Name of file
     * @exception	IOException occure when writing is failed.
     */
    public void write (String fileName) throws IOException {
        FileWriter out=new FileWriter(fileName);
        write(out,0,document.getLength());
        out.close();
    }

    /**
     * Performs writing to a writer.
     *
     * @param	out writer
     * @exception	IOException occure when writing is failed.
     */
    public void write(Writer out,int pos, int len) throws IOException {
        Element root=getDocumentTree();
        JTree tree=new JTree((TreeNode)root);

        fontList=new Vector();
        fontList.add("Arial");
        fontList.add("Wingdings");
        fontList=getFontList(root,fontList);
        colorList=getDefaultColorList();
        colorList=getColorList(root,colorList);

        out.write("{\\rtf1\\ansi\\ansicpg1252");
        out.write(createFontTable(fontList));
        out.write(createColorTable(colorList));

        writeContent(root,out,0,pos,len);
        out.write("}");
    }

    /**
     * writes content of the element.
     *
     * @param	root The root element.
     * @param	out writer
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeContent(Element root, Writer out, int level, int pos, int len) throws IOException {
        int elCount=root.getElementCount();
        int startIndex=root.getElementIndex(pos);
        int endIndex=root.getElementIndex(pos+len);
        for (int i=startIndex; i<=endIndex; i++) {
            Element child=root.getElement(i);
            if (child.getStartOffset()>pos+len)
                return;
            if (child.getName().equals("paragraph")) {
                if ((level>0) && (i==elCount-1)) {
                    writeParagraph(child,out,level,true,pos,len);
                }
                else {
                    writeParagraph(child,out,level,false,pos,len);
                }
            }
            else if (child.getName().equals("table")) {
                writeTable(child,out,level);
                if (i==endIndex) {
                    out.write("\\pard\\intbl");
                }
            }
        }
    }

    /**
     * writes content of single paragraph.
     *
     * @param	paragraph
     * @param	out writer
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @param	lastInTable if true that means paragraph is last paragraph in
     *   the table cell.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeParagraph (Element paragraph,Writer out,int level,boolean lastInTable,int pos,int len) throws IOException {
        out.write("\\pard ");
        int ind=0;
        int elCount=paragraph.getElementCount();
        out.write(getParagraphDescription(paragraph.getAttributes()));
        if (level>0) {
            out.write("\\intbl");
        }
        out.write("\\itap"+Integer.toString(level));
        int startIndex=paragraph.getElementIndex(pos);
        int endIndex=paragraph.getElementIndex(pos+len);
        for (int i=startIndex; i<=endIndex; i++) {
            Element leaf=paragraph.getElement(i);
            if (leaf.getName().equals("content")) {
                writeLeaf(leaf,out,pos,len);
            } else if (leaf.getName().equals("icon")) {
                writeIcon(leaf,out);
            }
        }
        if (!lastInTable)
            out.write("\\par");
    }

    /**
     * writes the leaf document's element.
     *
     * @param	leaf
     * @param	out writer
     * @exception	IOException occure when writing is failed.
     */
    protected void writeLeaf (Element leaf,Writer out,int pos, int len) throws IOException {
        AttributeSet attr=leaf.getAttributes();
        out.write(getBeforeFontDescription(attr,false)+" ");
        Document doc=leaf.getDocument();
        String contentText="";
        try {
            int start=Math.max(leaf.getStartOffset(),pos);
            int end=Math.min(leaf.getEndOffset(),pos+len)-start;
            contentText=convertString(doc.getText(start,end));
        }
        catch (Exception ex) {
            throw new IOException("Error reading leaf content from source document!");
        }
        out.write(contentText);
        String after=getAfterFontDescription(leaf.getAttributes());
        if (after.length()>0)
            out.write(getAfterFontDescription(leaf.getAttributes())+" ");
    }

    /**
     * writes an image.
     *
     * @param	leaf
     * @param	out writer
     * @exception	IOException occure when writing is failed.
     */
    protected void writeIcon (Element leaf,Writer out) throws IOException {
        AttributeSet attr=leaf.getAttributes();
        ImageIcon icon=(ImageIcon)StyleConstants.getIcon(attr);
        int w=StyleConstants.getIcon(attr).getIconWidth();
        int h=StyleConstants.getIcon(attr).getIconHeight();
        if (icon!=null) {
            ByteArrayOutputStream os=new ByteArrayOutputStream();
            PNGCodec p=new PNGCodec();
            ImageEncoder pe=p.createImageEncoder("PNG",os,null);
            BufferedImage bi=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
            bi.getGraphics().drawImage(icon.getImage(),0,0,null);
            pe.encode(bi);
            byte[] ba=os.toByteArray();

            int len=ba.length,i;
            StringBuffer sb=new StringBuffer(len*2);
            for (i=0;i<len;i++) {
                String sByte=Integer.toHexString((int)ba[i] & 0xFF);
                if (sByte.length()<2)
                    sb.append('0'+sByte);
                else
                    sb.append(sByte);
            }
            String s=sb.toString();
            String size=Integer.toString(s.length());
            out.write("{\\pict\\pngblip ");
            out.write(s);
            out.write("}");
        }
    }

    /**
     * writes table element.
     *
     * @param	table
     * @param	out writer
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeTable (Element table,Writer out,int level) throws IOException {
        int rowCount=table.getElementCount();
        for (int i=0; i<rowCount; i++) {
            Element row=table.getElement(i);
            writeRow(row,out,level);
        }
    }

    /**
     * writes row element.
     *
     * @param	row
     * @param	out writer
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeRow (Element row,Writer out,int level) throws IOException {
        for (int i=0; i<row.getElementCount(); i++) {
            writeCellContent(row.getElement(i),out,level);
        }

        if (level>0) {
            out.write("{\\*\\nesttableprops");
        }
        out.write("{\\trowd");
        AttributeSet attr=row.getAttributes();
        int indent=new Float(StyleConstants.getLeftIndent(attr)).intValue();
        out.write("\\tleft-"+Integer.toString(indent));

        out.write("\\trftsWidth1");
        out.write("\\trpaddl108");
        out.write("\\trpaddr108");
        out.write("\\trpaddfl3");
        out.write("\\trpaddfr3 ");
        int x=1; //word can't place table in 0-position of page (insets)
        for (int i=0; i<row.getElementCount(); i++) {
            AdvancedRTFDocument.CellElement cell=(AdvancedRTFDocument.CellElement)row.getElement(i);
            Double dX=convertPixelsToTwips(new Double(x));
            writeCell(row.getElement(i),out,dX.intValue(),level);
            x+=cell.getWidth();
        }
        if (level==0) {
            out.write("\\row}");
        }
        else {
            out.write("\\nestrow}}");
        }
    }

    /**
     * writes content of the cell.
     *
     * @param	cell
     * @param	out writer
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeCellContent (Element cell,Writer out,int level) throws IOException {
        writeContent(cell,out,level+1,cell.getStartOffset(),cell.getEndOffset()-cell.getStartOffset());
        if (level==0)
            out.write("\\cell");
        else {
            out.write("\\nestcell{\\nonesttables\\par }");
        }
    }

    /**
     * writes cell.
     *
     * @param	cell
     * @param	out writer
     * @param	x X-coordinate of the cell
     * @param	level content level (default 0). If element in the table level
     *   is 1. if it in the nested table level is 2 etc.
     * @exception	IOException occure when writing is failed.
     */
    protected void writeCell (Element cell,Writer out, int x,int level) throws IOException {
        out.write("\\clvertalt");
        AttributeSet attr=cell.getAttributes();

        BorderAttributes ba=(BorderAttributes)attr.getAttribute("BorderAttributes");
        if (ba!=null) {
            String borderType="\\brdrs";

            Color bc=ba.lineColor;
            String lineColor="";
            if (bc!=Color.black)
                lineColor="\\brdrcf"+(colorList.indexOf(bc)+1);

            if (ba.borderTop!=0)
                out.write("\\clbrdrt"+borderType+"\\brdrw10"+lineColor);
            if (ba.borderLeft!=0)
                out.write("\\clbrdrl"+borderType+"\\brdrw10"+lineColor);
            if (ba.borderBottom!=0)
                out.write("\\clbrdrb"+borderType+"\\brdrw10"+lineColor);
            if (ba.borderRight!=0)
                out.write("\\clbrdrr"+borderType+"\\brdrw10"+lineColor);
            out.write("\\clftsWidth3");
        }
        AdvancedRTFDocument.CellElement currentCell=(AdvancedRTFDocument.CellElement)cell;
        Double dWidth=convertPixelsToTwips(new Double(currentCell.getWidth()));
        out.write("\\clwWidth"+Integer.toString(dWidth.intValue()));
        out.write("\\cellx"+Integer.toString(x)+" ");
    }

    /**
     * Gets tree of the document's elements.
     */
    protected Element getDocumentTree() {
        StyledDocument doc=(StyledDocument)document;
        return doc.getDefaultRootElement();
    }

    /**
     * Gets fonts which used in subtree.
     *
     * @param	root root of subtree.
     * @param	list list of the fonts
     */
    protected Vector getFontList(Element root,Vector list) {
        //processing root
        AttributeSet attr=root.getAttributes();
        String curFontName=StyleConstants.getFontFamily(attr);
        if (!isInList(list,curFontName)) {
            list.add(curFontName);
        }
        //processing childs
        int i,cnt=root.getElementCount();
        for (i=0;i<cnt;i++) {
            Element el=root.getElement(i);
            list=getFontList(el,list);
        }
        return list;
    }

    /**
     * Checks whether object is in list.
     *
     * @param	list
     * @param	fontName
     */
    protected boolean isInList(Vector list,Object fontName) {
        int i,len=list.size();
        for (i=0;i<len;i++) {
            if ( fontName.equals(list.get(i)) )
                return true;
        }

        return false;
    }

    /**
     * Creates text representation of the font table.
     *
     * @param	fontList list of the document's fonts.
     */
    protected String createFontTable (Vector fontList) {
        String result="";
        int fontN=0;
        result+="{\\fonttbl";
        int i,len=fontList.size();
        for (i=0;i<len;i++) {
            result+="{\\f"+new Integer(fontN).toString();
            fontN++;
            result+="\\fnil\\fcharset1\\fprq2 ";
            result+=(String)fontList.get(i)+";}";
        }
        result+="}";
        return result;
    }

    /**
     * Gets list of default available colors.
     */
    protected Vector getDefaultColorList () {
        Vector result=new Vector();
        int[] values = new int[] { 0, 128, 192, 255 };
        for (int r=0; r<values.length; r++) {
            for (int g=0; g<values.length; g++) {
                for (int b=0; b<values.length; b++) {
                    Color c = new Color(values[r], values[g], values[b]);
                    result.add(c);
                }
            }
        }
        return result;
    }

    /**
     * Gets list of the colors encountered in the tree
     *
     * @param	root Root of the tree
     * @param	list color list.
     */
    protected Vector getColorList(Element root,Vector list) {
        AttributeSet attr=root.getAttributes();
        Color bgColor=StyleConstants.getBackground(attr);
        if (!isInList(list,bgColor)) {
            list.add(bgColor);
        }
        Color fgColor=StyleConstants.getForeground(attr);
        if (!isInList(list,fgColor)) {
            list.add(fgColor);
        }
        BorderAttributes ba=(BorderAttributes)attr.getAttribute("BorderAttributes");
        if (ba!=null) {
            if (!isInList(list,ba.lineColor)) {
                list.add(ba.lineColor);
            }
        }
        //processing childs
        int i,cnt=root.getElementCount();
        for (i=0;i<cnt;i++) {
            Element el=root.getElement(i);
            list=getColorList(el,list);
        }
        return list;
    }

    /**
     * Creates text representation of the color table.
     *
     * @param	colorList list of the document's colors.
     */
    protected String createColorTable (Vector colorList) {
        String result="";
        int red,green,blue;
        result+="{\\colortbl;";
        int i,len=colorList.size();
        for (i=0;i<len;i++) {
            Color c=(Color)colorList.get(i);
            red=c.getRed();
            green=c.getGreen();
            blue=c.getBlue();
            result+="\\red"+new Integer(red).toString();
            result+="\\green"+new Integer(green).toString();
            result+="\\blue"+new Integer(blue).toString()+";";
        }
        result+="}";
        return result;
    }

    /**
     * Gets precede font description.
     *
     * @param	attr Font attributes.
     */
    protected String getBeforeFontDescription (AttributeSet attr,boolean isStyle) {
        String result="";
        // --- FONT ---
        if (StyleConstants.isBold(attr))
            result+="\\b";
        if (StyleConstants.isItalic(attr))
            result+="\\i";
        if (StyleConstants.isUnderline(attr))
            result+="\\ul";

        if (StyleConstants.isStrikeThrough(attr))
            result+="\\strike";
        if (StyleConstants.isSubscript(attr))
            result+="\\sub";
        if (StyleConstants.isSuperscript(attr))
            result+="\\super";

        result+="\\f"+fontList.indexOf(StyleConstants.getFontFamily(attr));
        result+="\\fs"+new Integer(StyleConstants.getFontSize(attr)*2).toString();
        // --- COLORS --- attr.isDefined("foreground")
        Color fg=(Color)attr.getAttribute(StyleConstants.Foreground);
        if (fg!=null) {
            if (!isStyle)
                result+="{";
            result+="\\cf"+(colorList.indexOf(fg)+1);
        }

        Color bg=(Color)attr.getAttribute(StyleConstants.Background);
        if (bg!=null) {
            if (!isStyle)
                result+="{";
            result+="\\highlight"+(colorList.indexOf(bg)+1);
        }
        return result;
    }

    /**
     * Gets succeed font description.
     *
     * @param	attr Font attributes.
     */
    protected String getAfterFontDescription (AttributeSet attr) {
        String result="";
        // --- COLORS --- attr.isDefined("foreground")
        Color bg=(Color)attr.getAttribute(StyleConstants.Background);
        if (bg!=null)
            result+="}";
        Color fg=(Color)attr.getAttribute(StyleConstants.Foreground);
        if (fg!=null)
            result+="}";
        // --- FONT ---
        if (StyleConstants.isBold(attr))
            result+="\\b0";
        if (StyleConstants.isItalic(attr))
            result+="\\i0";
        if (StyleConstants.isUnderline(attr))
            result+="\\ulnone";

        if (StyleConstants.isStrikeThrough(attr))
            result+="\\strike0";
        if (StyleConstants.isSubscript(attr))
            result+="\\sub0";
        if (StyleConstants.isSuperscript(attr))
            result+="\\super0";
        return result;
    }

    /**
     * Get text representation of the paragraph.
     *
     * @param	attr Paragraph attributes.
     */
    protected String getParagraphDescription (AttributeSet attr) {
        String result="";
        StyleConstants.getIcon(attr);
        // --- ALIGNMENT ---
        switch (StyleConstants.getAlignment(attr)) {
            case StyleConstants.ALIGN_LEFT:
                result+="\\ql ";
                break;
            case StyleConstants.ALIGN_RIGHT:
                result+="\\qr ";
                break;
            case StyleConstants.ALIGN_CENTER:
                result+="\\qc ";
                break;
            case StyleConstants.ALIGN_JUSTIFIED:
                result+="\\qj ";
        }
        // --- TabSet ---
        Double f;
        TabSet ts=StyleConstants.getTabSet(attr);
        if (ts!=null)
            for (int i=0; i<ts.getTabCount(); i++) {
        TabStop stop=ts.getTab(i);
        f=new Double(stop.getPosition());
        f=convertPixelsToTwips(f);
        result+="\\tx"+new Integer(f.intValue()).toString();
            }
            // --- INDENT AND SPACING---
            if (StyleConstants.getLeftIndent(attr)!=0) {
                f=new Double(StyleConstants.getLeftIndent(attr));
                f=convertPixelsToTwips(f);
                result+="\\li"+new Integer(f.intValue()).toString();
            }
            if (StyleConstants.getRightIndent(attr)!=0) {
                f=new Double(StyleConstants.getRightIndent(attr));
                f=convertPixelsToTwips(f);
                result+="\\ri"+new Integer(f.intValue()).toString();
            }
            if (StyleConstants.getFirstLineIndent(attr)!=0) {
                f=new Double(StyleConstants.getFirstLineIndent(attr));
                f=convertPixelsToTwips(f);
                result+="\\fi"+new Integer(f.intValue()).toString();
            }

            if (StyleConstants.getSpaceAbove(attr)!=0) {
                f=new Double(StyleConstants.getSpaceAbove(attr));
                f=convertPixelsToTwips(f);
                result+="\\sa"+new Integer(f.intValue()).toString();
            }
            if (StyleConstants.getSpaceBelow(attr)!=0) {
                f=new Double(StyleConstants.getSpaceBelow(attr));
                f=convertPixelsToTwips(f);
                result+="\\sb"+new Integer(f.intValue()).toString();
            }
            if (StyleConstants.getLineSpacing(attr)!=0) {
                f=new Double(StyleConstants.getLineSpacing(attr));
                f=convertPixelsToTwips(f);
                result+="\\sl"+new Integer(f.intValue()).toString();
            }
            return result;
    }

    /**
     * Convert pixel measure into the twips.
     *
     * @param	value
     */
    protected Double convertPixelsToTwips (Double value) {
        double result=value.doubleValue();
        //75 pixel per inch
        //convert to sm
        result=result/72*2.5;
        //use MS word sizes 12240 twips = 210 mm
        result=result/21*12240;
        return new Double(result);
    }

    /**
     * Converts string. (replace tab character and "\" character)
     * @param	source converted string
     * @return sting with replaced characters
     */
    protected String convertString(String source) {
        String dest="";
        int i=0;
        int index=source.indexOf('\\',i);
        while (index>=0) {
            dest+=source.substring(i,index+1)+'\\';
            i=index+1;
            index=source.indexOf('\\',i);
        }
        dest+=source.substring(i);
        source=dest;
        dest="";

        i=0;
        index=source.indexOf('\t',i);
        while (index>=0) {
            dest+=source.substring(i,index)+'\\'+"tab ";
            i=index+1;
            index=source.indexOf('\t',i);
        }
        dest+=source.substring(i);

        i=0;
        String src=dest;
        dest="";
        index=src.indexOf('{',i);
        while (index>=0) {
            dest+=src.substring(i,index)+'\\'+'{';
            i=index+1;
            index=src.indexOf('{',i);
        }
        dest+=src.substring(i);
        i=0;

        src=dest;
        dest="";
        index=src.indexOf('}',i);
        while (index>=0) {
            dest+=src.substring(i,index)+'\\'+'}';
            i=index+1;
            index=src.indexOf('}',i);
        }
        dest+=src.substring(i);

        return dest;
    }

}